из lark подключить (
    Lark как Жаворонок, 
    Transformer как Преобразователь, 
    UnexpectedToken как НепредвиденныйТокен, 
    UnexpectedCharacters как НепредвиденныеСимволы, 
    UnexpectedEOF как НепредвиденныйКФ
)
из lark.indenter подключить Indenter как Отступник
из json подключить load как загрузить
из traceback подключить format_exc


класс ОтступникПитона(Отступник):
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 8


символ_отступа: строка = "    "


объявить добавить_отступ(текст: строка) -> строка:
    если текст.обрезать():
        вернуть текст.заменить("\n", "\n" + символ_отступа)
    вернуть ""


объявить с_пробелом(текст):
    вернуть " ".соединить(["", текст])


объявить пропустить_пустые(токены):
    вернуть фильтр(Ничего, токены)


объявить проверка_интерполяции(токен, курсор):
    вложенность = 0
    для смещение в диапазон(курсор, длина(токен)):
        если токен[смещение] == "{":
            вложенность += 1
        иначеесли токен[смещение] == "}":
            вложенность -= 1
        если вложенность < 0:
            вернуть смещение
    иначе:
        бросить ОшибкаЗначения("Неверная интерполяция")


объявить получить_парсеры(файл_грамматики):
    с открыть(файл_грамматики) как файл:
        грамматика = файл.читать()
    
    аргументы = словарь(
        парсер="lalr",
        postlex=ОтступникПитона(),
        maybe_placeholders=Да,
    )
    
    парсер = Жаворонок(
        грамматика,
        start="file_input",
        **аргументы,
    )

    вычислительный_парсер = Жаворонок(
        грамматика,
        start="eval_input",
        **аргументы,
    )
    вернуть парсер, вычислительный_парсер


класс БазовыйГенератор(Преобразователь):
    ключи = {
        "if": "if",
        "else": "else",
        "elif": "elif",
        "while": "while",
        "for": "for",
        "try": "try",
        "except": "except",
        "finally": "finally",
        "from": "from",
        "in": "in",
        "import": "import",
        "as": "as",
        "pass": "pass",
        "continue": "continue",
        "break": "break",
        "return": "return",
        "def": "def",
        "raise": "raise",
        "assert": "assert",
        "class": "class",
        "yield": "yield",
        "await": "await",
        "async": "async",
        "lambda": "lambda",
        "None": "None",
        "True": "True",
        "False": "False",
        "and": "and",
        "or": "or",
        "not": "not",
        "is": "is",
        "del": "del",
        "global": "global",
        "nonlocal": "nonlocal",
        "with": "with",
        "orig_in": "в",
        "orig_is": "есть",
        "orig_not": "не"
    }

    объявить file_input(сам, токены):
        вернуть "\n".соединить(токены)

    объявить eval_input(сам, токены):
        вернуть токены[0]

    объявить __полатр__(сам, атрибут):
        если атрибут.есть_верхний():
            вернуть лямбда токен: токен

        вывод(ф"!!! {атрибут} не преобразован !!!")
        вернуть лямбда токены: " ".соединить(токены)

    объявить one_line_suite(сам, токены):
        вернуть токены[0]

    объявить suite(сам, токены):
        вернуть добавить_отступ("\n" + "\n".соединить(токены))

    объявить if_stmt(сам, токены):
        иначе_ = (ф"\n{сам.ключи['else']}:" + токены[3]) если токены[3] иначе ""

        вернуть "".соединить(
            [
                сам.ключи['if'], " ",
                токены[0],
                ":",
                токены[1],
                *(["\n", токены[2]] если токены[2] иначе ""),
                иначе_,
            ]
        )

    объявить elifs(сам, токены):
        вернуть "\n".соединить(токены)

    объявить elif_(сам, токены):
        вернуть "".соединить([сам.ключи['elif'], " ", токены[0], ":", токены[1]])

    объявить import_from(сам, токены):
        вернуть " ".соединить([
            сам.ключи['from'], 
            "".соединить(токены[:-1]), 
            сам.ключи['import'], 
            токены[-1]
        ])

    объявить import_name(сам, токены):
        вернуть " ".соединить([сам.ключи['import'], токены[0]])

    объявить dotted_as_name(сам, токены):
        вернуть f" {сам.ключи['as']} ".соединить(пропустить_пустые(токены))

    объявить import_as_name(сам, токены):
        вернуть f" {сам.ключи['as']} ".соединить(пропустить_пустые(токены))

    объявить dotted_as_names(сам, токены):
        вернуть ", ".соединить(токены)

    объявить import_as_names(сам, токены):
        вернуть ", ".соединить(токены)

    объявить dotted_name(сам, токены):
        вернуть ".".соединить(токены)

    объявить dots(сам, токены):
        вернуть "".соединить(токены)

    объявить global_stmt(сам, токены):
        вернуть " ".соединить([сам.ключи['global'], ", ".соединить(токены)])

    объявить nonlocal_stmt(сам, токены):
        вернуть " ".соединить([сам.ключи['nonlocal'], ", ".соединить(токены)])

    объявить assert_stmt(сам, токены):
        вернуть " ".соединить([сам.ключи['assert'], ", ".соединить(пропустить_пустые(токены))])

    объявить raise_stmt(сам, токены):
        вернуть " ".соединить([сам.ключи['raise'], f" {сам.ключи['from']} ".join(пропустить_пустые(токены))])

    объявить while_stmt(сам, токены):
        иначе_ = (ф"\n{сам.ключи['else']}:" + токены[2]) если токены[2] иначе ""

        вернуть "".соединить(
            [
                сам.ключи['while'],
                " ",
                токены[0],
                ":",
                токены[1],
                иначе_,
            ]
        )

    объявить continue_stmt(сам, токены):
        вернуть сам.ключи['continue']

    объявить break_stmt(сам, токены):
        вернуть сам.ключи['break']

    объявить assign(сам, токены):
        вернуть " = ".соединить(токены)

    объявить slice(сам, токены):
        токены = [x или '' для x в токены]
        вернуть "{}:{}{}".формат(*токены)

    объявить sliceop(сам, токены):
        если токены[0]:
            вернуть ф":{токены[0]}"

    объявить var(сам, токены):
        вернуть токены[0]

    объявить test(сам, токены):
        вернуть "{0} {3} {1} {4} {2}".формат(*токены, сам.ключи['if'], сам.ключи['else'])

    объявить star_expr(сам, токены):
        вернуть ф"*{токены[0]}"

    объявить funccall(сам, токены):
        вернуть ф"{токены[0]}({токены[1] или ''})"

    объявить arguments(сам, токены):
        вернуть ", ".соединить(пропустить_пустые(токены))

    объявить argvalue(сам, токены):
        вернуть "=".соединить(токены)

    объявить starargs(сам, токены):
        вернуть ", ".соединить(пропустить_пустые(токены))

    объявить stararg(сам, токены):
        вернуть ф"*{токены[0]}"

    объявить kwargs(сам, токены):
        вернуть ф"**{токены[0]}"

    объявить subscript_tuple(сам, токены):
        вернуть ", ".соединить(токены)

    объявить parens(self, tokens):
        вернуть ф"({tokens[0]})"

    объявить getitem(сам, токены):
        вернуть ф"{токены[0]}[{токены[1]}]"

    объявить getattr(сам, токены):
        вернуть ".".соединить(токены)

    объявить NAME(сам, токен):
        вернуть сам.переводы.получить(токен, токен)

    объявить annassign(сам, токены):
        если токены[2]:
            вернуть ф"{токены[0]}: {токены[1]} = {токены[2]}"
        вернуть ф"{токены[0]}: {токены[1]}"

    объявить augassign(сам, токены):
        вернуть " ".соединить(токены)

    объявить augassign_op(сам, токены):
        вернуть токены[0]

    объявить float(сам, токены):
        вернуть токены[0]

    объявить integer(сам, токены):
        вернуть токены[0]

    объявить complex(сам, токены):
        вернуть токены[0]

    объявить string(сам, токены):
        вернуть токены[0]

    объявить with_stmt(сам, токены):
        вернуть "{2} {0}:{1}\n".формат(*токены, сам.ключи['with'])

    объявить with_items(сам, токены):
        вернуть ", ".соединить(токены)

    объявить with_item(сам, токены):
        вернуть ф" {сам.ключи['as']} ".соединить(пропустить_пустые(токены)) 

    объявить STRING(сам, токен):
        если токен[0] в "юбфрЮБФР":
            токен = "ubfrUBFR"["юбфрЮБФР".индекс(токен[0])] + токен[1:]
        
        если токен.нижний().начинаетсяс("f"):
            результат = []
            интерполяции = [0]
            скобка = Нет
            индекс = 0

            # выделяем части, которые нужно преобразовать
            пока индекс < длина(токен):
                если скобка:
                    скобка = Нет
                    индекс += 1
                    продолжить
                если токен[индекс] == "{":
                    если токен[индекс + 1:индекс + 2] == "{":
                        скобка = Да
                        продолжить
                    если не скобка:
                        интерполяции.добавить(индекс + 1)
                        индекс = проверка_интерполяции(токен, индекс + 1)
                        интерполяции.добавить(индекс)
                скобка = Нет
                индекс += 1
            интерполяции.добавить(длина(токен))
            
            для индекс в диапазон(длина(интерполяции[:-1])):
                часть = токен[интерполяции[индекс]: интерполяции[индекс + 1]]
                если индекс % 2:
                    часть_ = часть.разделить(":")
                    если длина(часть_) > 1:
                        *часть, фмт = часть_
                    иначе:
                        часть = часть_
                        фмт = Ничего
                    часть = сам.преобразовать(сам.вычислительный_парсер.парсить(":".соединить(часть)))
                    результат.добавить(
                        ":".соединить(
                            пропустить_пустые([часть, фмт])
                        )
                    )
                иначе:
                    результат.добавить(часть)
            вернуть "".соединить(результат)

        вернуть токен

    объявить funcdef(сам, токены):
        вернуть ф"\n{сам.ключи['def']} {токены[0]}({токены[1] или ''}){' -> '.соединить(['', *пропустить_пустые([токены[2]])])}: {токены[3]}"

    объявить parameters(сам, токены):
        вернуть ", ".соединить(пропустить_пустые(токены))

    объявить paramvalue(сам, токены):
        вернуть " = ".соединить(токены)

    объявить const_true(сам, токены):
        вернуть сам.ключи['True']

    объявить const_false(сам, токены):
        вернуть сам.ключи['False']

    объявить const_none(сам, токены):
        вернуть сам.ключи['None']

    объявить starparams(сам, токены):
        вернуть "".соединить(["*", ", ".соединить(пропустить_пустые(токены))])

    объявить kwparams(сам, токены):
        вернуть ф"**{токены[0]}"

    объявить typedparam(сам, токены):
        вернуть ": ".соединить(токены)

    объявить return_stmt(сам, токены):
        вернуть " ".соединить([сам.ключи['return'], *пропустить_пустые(токены)])

    объявить lambdef(сам, токены):
        вернуть "".соединить([сам.ключи['lambda'], с_пробелом(токены[0] или ""), ": ", токены[1]])

    объявить lambda_params(сам, токены):
        вернуть ", ".соединить(пропустить_пустые(токены))

    объявить lambda_paramvalue(сам, токены):
        вернуть "=".соединить(пропустить_пустые(токены))

    объявить lambda_starparams(сам, токены):
        вернуть ", ".соединить(пропустить_пустые(токены))

    объявить lambda_kwparams(сам, токены):
        вернуть ф"**{токены[0]}"

    объявить or_test(сам, токены):
        вернуть ф" {сам.ключи['or']} ".соединить(токены)

    объявить and_test(сам, токены):
        вернуть ф" {сам.ключи['and']} ".соединить(токены)

    объявить not_test(сам, токены):
        вернуть ф"{сам.ключи['not']} {токены[0]}"

    объявить or_expr(сам, токены):
        вернуть " | ".соединить(токены)

    объявить xor_expr(сам, токены):
        вернуть " ^ ".соединить(токены)

    объявить and_expr(сам, токены):
        вернуть " & ".соединить(токены)

    объявить power(сам, токены):
        вернуть " ** ".соединить(токены)

    объявить comparison(сам, токены):
        вернуть " ".соединить(токены)

    объявить comp_op(сам, токены):
        вернуть токены[0].replace(
            сам.ключи['orig_not'], сам.ключи['not']
        ).replace(
            сам.ключи['orig_is'], сам.ключи['is']
        ).replace(
            сам.ключи['orig_in'], сам.ключи['in']
        )

    объявить многострочный_список(сам, токены):
        вернуть добавить_отступ("\n" + ",\n".соединить(токены))

    объявить list(сам, токены):
        если длина(токены) > 5 или любой("\n" в токен для токен в токены):
            вернуть "".соединить(["[", сам.многострочный_список(токены), "\n]"]) 
        вернуть ф"[{', '.соединить(токены)}]"

    объявить dict(сам, токены):
        если длина(токены) > 5 или любой("\n" в токен для токен в токены):
            вернуть "".соединить(["{", сам.многострочный_список(токены), "\n}"]) 
        вернуть ф"{{{', '.соединить(токены)}}}"

    объявить set(сам, токены):
        если длина(токены) > 5 или любой("\n" в токен для токен в токены):
            вернуть "".соединить(["{", сам.многострочный_список(токены), "\n}"]) 
        вернуть ф"{{{', '.соединить(токены)}}}"

    объявить dict_comprehension(сам, токены):
        вернуть ф"{{{токены[0]}}}"

    объявить shift_expr(сам, токены):
        вернуть " ".соединить(токены)

    объявить set_comprehension(сам, токены):
        вернуть ф"{{{токены[0]}}}"

    объявить list_comprehension(сам, токены):
        вернуть ф"[{токены[0]}]"

    объявить classdef(сам, токены):
        вернуть "".соединить(
            [
                f"\n{сам.ключи['class']} ",
                токены[0],
                ф"({токены[1]})" если токены[1] иначе "",
                ":",
                токены[2],
                "\n",
            ]
        )

    объявить comprehension(сам, токены):
        вернуть " ".соединить(пропустить_пустые(токены))

    объявить comp_fors(сам, токены):
        вернуть " ".соединить(токены)

    объявить comp_for(сам, токены):
        вернуть " ".соединить(
            [
                *пропустить_пустые([f"{сам.ключи['async']} " если токены[0] иначе ""]),
                сам.ключи['for'],
                токены[1],
                сам.ключи['in'],
                токены[2],
            ]
        )

    объявить comp_if(сам, токены):
        вернуть ф"{сам.ключи['if']} {токены[0]}"

    объявить exprlist(сам, токены):
        вернуть ", ".соединить(токены)

    объявить yield_expr(сам, токены):
        вернуть " ".соединить([сам.ключи['yield'], *пропустить_пустые(токены)])

    объявить yield_from(сам, токены):
        вернуть " ".соединить([сам.ключи['yield'], сам.ключи['from'], токены[0]])

    объявить arith_expr(сам, токены):
        вернуть " ".соединить(пропустить_пустые(токены))

    объявить key_value(сам, токены):
        вернуть ": ".соединить(токены)

    объявить decorator(сам, токены):
        вернуть "".соединить(["@", токены[0], ф"({токены[1]})" если токены[1] иначе ""])

    объявить decorators(сам, токены):
        вернуть "\n".соединить(токены)

    объявить decorated(сам, токены):
        вернуть "".соединить(["\n", *токены])

    объявить tuple(сам, токены):
        если токены:
            если длина(токены) > 5 или все("\n" в токен для токен в токены):
                вернуть "".соединить(["(", сам.многострочный_список(токены), ",\n)"]) 
            вернуть ф"({', '.соединить(токены)}, )"
        вернуть "()"

    объявить testlist_tuple(сам, токены):
        вернуть ", ".соединить(токены)

    объявить simple_stmt(сам, токены):
        вернуть "; ".соединить(токены)

    объявить for_stmt(сам, токены):
        else_ = (f"\n{сам.ключи['else']}:" + токены[3]) если токены[3] иначе ""

        вернуть "".соединить([f"{сам.ключи['for']} ", токены[0], f" {сам.ключи['in']} ", токены[1], ":", токены[2], else_])

    объявить term(сам, токены):
        вернуть " ".соединить(токены)

    объявить factor(сам, токены):
        вернуть " ".соединить(токены)

    объявить async_funcdef(сам, токены):
        вернуть " ".соединить([f"\n{сам.ключи['async']}", токены[0][1:]])

    объявить del_stmt(сам, токены):
        вернуть ф"{сам.ключи['del']} {токены[0]}"

    объявить await_expr(сам, токены):
        вернуть ф"{сам.ключи['await']} {токены[0]}"

    объявить try_stmt(сам, токены):
        else_ = (ф"{сам.ключи['else']}:" + токены[2]) если токены[2] иначе ""
        вернуть "\n".соединить(пропустить_пустые([ф"{сам.ключи['try']}: {токены[0]}", токены[1], else_ если токены[2] иначе "", токены[3], " "]))

    объявить try_finally(сам, токены):
        вернуть ф"\n{сам.ключи['try']}: {токены[0]}\n{токены[1]}"

    объявить except_clauses(сам, токены):
        вернуть "\n".соединить(токены)

    объявить except_clause(сам, токены):
        если длина(токены) == 2:
            токены.вставить(1, Ничего)
        вернуть "".соединить([
            сам.ключи['except'], 
            с_пробелом(
                f" {сам.ключи['as']} ".соединить(
                    пропустить_пустые(токены[:2])
                )
            ).побрезать(), ":", токены[2]])

    объявить finally_(сам, токены):
        вернуть ф"{сам.ключи['finally']}: {токены[0]}"

    объявить du_dct(сам, токены):
        вернуть ф"**{токены[0]}"
    
    объявить pass_stmt(сам, токены):
        вернуть сам.ключи['pass']


объявить репорт(код, ошибка, имя_файла="модуль"):
    номер_строки = ошибка.line
    размер = 3
    верхний_размер = минимум(номер_строки - 1, размер)

    строки = код.разделить("\n")[номер_строки - верхний_размер - 1: номер_строки + размер]
    отступ = ошибка.column
    ширина_номера_строки = длина(
        строка(
            максимум(
                номер_строки - верхний_размер, 
                номер_строки + размер
            )
        )
    )
    вернуть (
        "\n".соединить([
            *[
                f"{строка(i + номер_строки - верхний_размер):>{ширина_номера_строки}} | {line}"
                для i, line в пронумеровать(строки[:верхний_размер + 1]) 
            ],
            f"{'':>{ширина_номера_строки + 1}}:{'':>{отступ}}^ Ошибка: Непредвиденный {ошибка.токен.тип}",
            *[
                f"{строка(i + 1 + номер_строки):>{ширина_номера_строки}} | {line}"
                для i, line в пронумеровать(строки[верхний_размер + 1:])
            ],
        ])
    )

объявить преобразовать(код, парсер, преобразователь, имя_файла="модуль"):
    попробовать:
        дерево = парсер.парсить(код + "\n")
    кроме НепредвиденныйТокен как ошибка:
        вывод(репорт(код, ошибка, имя_файла))    
        вернуть Ничего, Ничего

    попробовать:
        результат = преобразователь.преобразовать(дерево)
    кроме Исключение:
        вывод(format_exc())
        вернуть Ничего, дерево
    
    вернуть результат, дерево